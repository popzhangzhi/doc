go 协程

1.go chanel 在输入数据 ch<- 1 和读取数据 value := <-ch 之前都是阻塞的。如果一个chan只写没有取，这个chan不会阻塞主进程
  同时 make(chan int , 1024) 第二参数不传默认是不带缓存的，意思是之前提到的每一个chan是阻塞的，传入代表带缓存，并且是大小（1024可容纳1024个
元素，并且先入先出）
 len(chan) 当前已存个数，cap(chan)为chanel容纳数量，也就是上文提到的1024
2.协程中输出未必能正常输出，协程和主进程交互可以通过chanel或者通过sync.mutex Lock(),在主进程中判断lock()后的标识来确认协程是否执行完
其原理是共用相同内存并且带锁。
3. 可以声明单向chanel。只读，只取。
	var ch1 chan int  　　　　// 普通channel
	var ch2 chan <- int 　　 // 只用于写int数据
	var ch3 <-chan int 　　 // 只用于读int数据
	也可以用个类型动态转化某个普通chanel变成当前通道
	ch4 := make(chan int)
	ch5 := <-chan int(ch4)   // 单向读
	ch6 := chan<- int(ch4)  //单向写
	单向channel的作用有点类似于c++中的const关键字，用于遵循代码“最小权限原则”。
4.select 用于监听chanel的io，类似于swtich但只有一个case能执行，如果所有case都不能满足，可以执行default。default是可选的。不存在default的时候，
会阻塞。等待某个case成立后执行一次。在写的时候，只有带缓存的chanel才能写，不带的永远都不会满足case
5. go chanel不会超时，但可以通过声明一个类似以下的chanel实现超时

	timeout := make(chan bool, 1)
	go func() {
		time.Sleep(5*time.Second)
		timeout <- true
	}()
	switch {
	case <- ch:
	// 从ch中读取到数据

	case <- timeout:
	// 没有从ch中读取到数据，但从timeout中读取到了数据
	}
