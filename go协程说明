go 协程

1.go chanel 在输入数据 ch<- 1 和读取数据 value := <-ch 之前都是阻塞，同时 make(chan int , 1024) 第二参数不传默认是不带缓存的，
意思是之前提到的每一个chan是阻塞的，传入代表带缓存，并且是大小（1024可容纳1024个元素，并且先入先出）
   len(chan) 当前已存个数，cap(chan)为chanel容纳数量，也就是上文提到的1024
   在一个已关闭 channel 上执行接收操作(<-ch)总是能够立即返回，返回值是对应类型的零值。
2.协程中输出未必能正常输出，协程和主进程交互可以通过chanel或者通过sync.mutex Lock(),在主进程中判断lock()后的标识来确认协程是否执行完
其原理是共用相同内存并且带锁。
3. 可以声明单向chanel。只读，只取。
	var ch1 chan int  　　　　// 普通channel
	var ch2 chan <- int 　　 // 只用于写int数据
	var ch3 <-chan int 　　 // 只用于读int数据
	也可以用个类型动态转化某个普通chanel变成当前通道
	ch4 := make(chan int)
	ch5 := <-chan int(ch4)   // 单向读
	ch6 := chan<- int(ch4)  //单向写
	单向channel的作用有点类似于c++中的const关键字，用于遵循代码“最小权限原则”。
4.select 用于监听chanel的io，类似于swtich但只有一个case能执行，如果所有case都不能满足，可以执行default。default是可选的。不存在default的时候，
会阻塞。等待某个case成立后执行一次。如果有满足多个case，会伪随机的执行其中一个case。在写的时候，只有带缓存的chanel才能写，不带的永远都不会满足case
5. go chanel不会超时，但可以通过声明一个类似以下的chanel实现超时

	timeout := make(chan bool, 1)
	go func() {
		time.Sleep(5*time.Second)
		timeout <- true
	}()
	switch {
	case <- ch:
	// 从ch中读取到数据

	case <- timeout:
	// 没有从ch中读取到数据，但从timeout中读取到了数据
	}
6. go runtime包中有几个处理goroutine的函数
	Goexit 退出当前执行的goroutine，但是defer函数还会继续调用

	Gosched 让出当前goroutine的执行权限，调度器安排其他等待的任务运行，并在下次某个时候从该位置恢复执行

	NumCPU 返回 CPU 核数量

	NumGoroutine 返回正在执行和排队的任务总数

	GOMAXPROCS 用来设置可以并行计算的CPU核数的最大值，并返回之前的值
